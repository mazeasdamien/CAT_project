// <autogenerated>
// WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
// DDS version: 3.31.0
// ACE version: 7.1.3
// Running on input file: RobotState.idl
// </autogenerated>

#pragma once

#include "RobotStateTypeSupportImpl.h"
#include "RobotStateC.h"
#include "marshal.h"

#ifndef EXTERN_METHOD_EXPORT
    #ifdef _WIN32
        #define EXTERN_METHOD_EXPORT extern "C" __declspec(dllexport)
    #else
        #define EXTERN_METHOD_EXPORT extern "C"
    #endif
#endif

#ifndef EXTERN_STRUCT_EXPORT
    #define EXTERN_STRUCT_EXPORT extern "C" struct
#endif

void RobotDDS_RobotState_CopyKeys(RobotDDS::RobotState *source, RobotDDS::RobotState *destination) {
};


/////////////////////////////////////////////////
// RobotState Type Support Methods
/////////////////////////////////////////////////
EXTERN_METHOD_EXPORT RobotDDS::RobotStateTypeSupport_ptr RobotDDS_RobotStateTypeSupport_new();

EXTERN_METHOD_EXPORT char* RobotDDS_RobotStateTypeSupport_GetTypeName(RobotDDS::RobotStateTypeSupport_ptr native);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateTypeSupport_RegisterType(RobotDDS::RobotStateTypeSupport_ptr native, ::DDS::DomainParticipant_ptr dp, const char* typeName);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateTypeSupport_UnregisterType(RobotDDS::RobotStateTypeSupport_ptr native, ::DDS::DomainParticipant_ptr dp, const char* typeName);

/////////////////////////////////////////////////
// RobotState DataWriter Methods
/////////////////////////////////////////////////
EXTERN_METHOD_EXPORT RobotDDS::RobotStateDataWriter_ptr RobotDDS_RobotStateDataWriter_Narrow(DDS::DataWriter_ptr dw);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_Write_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, int handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_Write_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, int handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_WriteWithTimestamp_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, int handle, ::DDS::Time_t time);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_WriteWithTimestamp_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, int handle, const char* time_data, size_t time_size);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_RegisterInstance_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_RegisterInstance_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_RegisterInstanceTimestamp_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, ::DDS::Time_t time);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_RegisterInstanceTimestamp_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, const char* time_data, size_t time_size);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_LookupInstance_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_LookupInstance_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_UnregisterInstance_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, ::DDS::InstanceHandle_t handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_UnregisterInstance_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, ::DDS::InstanceHandle_t handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_UnregisterInstanceTimestamp_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, ::DDS::InstanceHandle_t handle, ::DDS::Time_t time);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_UnregisterInstanceTimestamp_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, ::DDS::InstanceHandle_t handle, const char* time_data, size_t time_size);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_Dispose_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, int handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_Dispose_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, int handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_DisposeTimestamp_Json(RobotDDS::RobotStateDataWriter_ptr dw, const char* json_data, int handle, ::DDS::Time_t time);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_DisposeTimestamp_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, const char* cdr_data, size_t size, int handle, const char* time_data, size_t time_size);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_GetKeyValue_Json(RobotDDS::RobotStateDataWriter_ptr dw, char* & json_data, int handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataWriter_GetKeyValue_Cdr(RobotDDS::RobotStateDataWriter_ptr dw, char* & cdr_data, size_t & size, int handle);

/////////////////////////////////////////////////
// RobotState DataReader Methods
/////////////////////////////////////////////////
EXTERN_METHOD_EXPORT RobotDDS::RobotStateDataReader_ptr RobotDDS_RobotStateDataReader_Narrow(DDS::DataReader_ptr dr);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_ReadNextSample_Json(RobotDDS::RobotStateDataReader_ptr dr, char* & json_data, ::DDS::SampleInfo* sampleInfo);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_ReadNextSample_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char* & cdr_data, size_t & size, char* & cdr_info, size_t & size_info);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_TakeNextSample_Json(RobotDDS::RobotStateDataReader_ptr dr, char* & json_data, ::DDS::SampleInfo* sampleInfo);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_TakeNextSample_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char* & cdr_data, size_t & size, char* & cdr_info, size_t & size_info);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_Read_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_Read_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadWithCondition_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadWithCondition_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_Take_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_Take_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeWithCondition_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeWithCondition_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_LookupInstance_Json(RobotDDS::RobotStateDataReader_ptr dr, const char* json_data);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_LookupInstance_Cdr(RobotDDS::RobotStateDataReader_ptr dr, const char* cdr_data, size_t size);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadInstance_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadInstance_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadInstanceWithCondition_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadInstanceWithCondition_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeInstance_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeInstance_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeInstanceWithCondition_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeInstanceWithCondition_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadNextInstance_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadNextInstance_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadNextInstanceWithCondition_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_ReadNextInstanceWithCondition_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeNextInstance_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeNextInstance_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeNextInstanceWithCondition_Json(RobotDDS::RobotStateDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT ::DDS::ReturnCode_t RobotDDS_RobotStateDataReader_TakeNextInstanceWithCondition_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_GetKeyValue_Json(RobotDDS::RobotStateDataReader_ptr dr, char* & json_data, int handle);

EXTERN_METHOD_EXPORT int RobotDDS_RobotStateDataReader_GetKeyValue_Cdr(RobotDDS::RobotStateDataReader_ptr dr, char*& cdr_data, size_t & size_data, int handle);

/*
#include <fstream>
using std::ofstream;
#include <iostream>
using std::cout;
using std::endl;
using namespace std;

/////////////////////////////////////////////////
// RobotState Utility Methods
/////////////////////////////////////////////////
int RobotDDS_RobotState_to_file(const char* json_data)
{
    ofstream stream;

    stream.open("./mysample.txt", std::ofstream::binary);
    if( !stream )
        cout << "Opening file failed" << endl;
    // use operator<< for clarity
    stream << json_data << endl;
    // test if write was succesful - not *really* necessary
    if( !stream )
        cout << "Write failed" << endl;

    return 0;
}
*/

RobotDDS::RobotState_var RobotDDS_RobotState_DecodeJsonSample(const char* json_data)
{
    //RobotDDS_RobotState_to_file(json_data);
    RobotDDS::RobotStateTypeSupport_var ts = new RobotDDS::RobotStateTypeSupportImpl;
    OpenDDS::DCPS::RepresentationFormat_var format = ts->make_format(OpenDDS::DCPS::JSON_DATA_REPRESENTATION);
    RobotDDS::RobotState_var samplev;
    ::DDS::ReturnCode_t ret = ts->decode_from_string(json_data, samplev, format);
    if (ret != ::DDS::RETCODE_OK)
    {
        return NULL;
    }

    return samplev;
}

char* RobotDDS_RobotState_EncodeJsonSample(RobotDDS::RobotState sample)
{
    RobotDDS::RobotStateTypeSupport_var ts = new RobotDDS::RobotStateTypeSupportImpl;
    OpenDDS::DCPS::RepresentationFormat_var format = ts->make_format(OpenDDS::DCPS::JSON_DATA_REPRESENTATION);
    CORBA::String_var buffer;
    ts->encode_to_string(sample, buffer, format);
    return CORBA::string_dup(buffer);
}

void RobotDDS_RobotState_serialize_to_bytes(const RobotDDS::RobotState& idl_value, char* &data, size_t &size)
{
  const OpenDDS::DCPS::Encoding encoding(OpenDDS::DCPS::Encoding::KIND_XCDR1, OpenDDS::DCPS::ENDIAN_LITTLE);

  const size_t xcdr_size = OpenDDS::DCPS::serialized_size(encoding, idl_value);
  ACE_Message_Block mb(xcdr_size);
  OpenDDS::DCPS::Serializer serializer(&mb, encoding);
  if (!(serializer << idl_value)) {
    throw std::runtime_error("Failed to serialize sample of type RobotDDS::RobotState.");
  }
  data = (char*)malloc(xcdr_size);
  memcpy(data, mb.base(), xcdr_size);
  size = xcdr_size;
}

void RobotDDS_RobotStateSeq_serialize_to_bytes(const RobotDDS::RobotStateSeq& seq_data, char* &data, size_t &size)
{
  const OpenDDS::DCPS::Encoding encoding(OpenDDS::DCPS::Encoding::KIND_XCDR1, OpenDDS::DCPS::ENDIAN_LITTLE);

  size_t total_size = 0;
  OpenDDS::DCPS::primitive_serialized_size(encoding, total_size, seq_data.length());

  for (CORBA::ULong i = 0; i < seq_data.length(); i++) {
     total_size += OpenDDS::DCPS::serialized_size(encoding, seq_data[i]);
  }

  // Ensure extra space for struct alignment
  total_size += seq_data.length() * 8;

  ACE_Message_Block mb(total_size);
  OpenDDS::DCPS::Serializer serializer(&mb, encoding);

  if (!(serializer << ACE_CDR::ULong(seq_data.length()))) {
    throw std::runtime_error("Failed to serialize sequence length.");
  }

  for (CORBA::ULong i = 0; i < seq_data.length(); i++) {
    if (!(serializer << seq_data[i])) {
      throw std::runtime_error("Failed to serialize sequence of type RobotDDS::RobotState." + std::to_string(i));
    }
  }

   data = (char*)malloc(total_size);
   memcpy(data, mb.base(), total_size);
   size = total_size;
}

RobotDDS::RobotState RobotDDS_RobotState_deserialize_from_bytes(const char* xcdr, size_t size)
{
  const OpenDDS::DCPS::Encoding encoding(OpenDDS::DCPS::Encoding::KIND_XCDR1, OpenDDS::DCPS::ENDIAN_LITTLE);
  ACE_Message_Block mb(size);
  mb.copy(xcdr, size);
  OpenDDS::DCPS::Serializer serializer(&mb, encoding);
  RobotDDS::RobotState idl_value;
  if (!(serializer >> idl_value)) {
    throw std::runtime_error("failed to deserialize");
  }
  return idl_value;
}

