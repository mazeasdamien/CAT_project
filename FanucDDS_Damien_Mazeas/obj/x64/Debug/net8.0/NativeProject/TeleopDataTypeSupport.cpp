// <autogenerated>
// WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
// DDS version: 3.31.0
// ACE version: 7.1.3
// Running on input file: TeleopData.idl
// </autogenerated>

#include "TeleopDataTypeSupport.h"


RobotDDS::TeleopDataTypeSupport_ptr RobotDDS_TeleopDataTypeSupport_new()
{
    return new RobotDDS::TeleopDataTypeSupportImpl();
}

char* RobotDDS_TeleopDataTypeSupport_GetTypeName(RobotDDS::TeleopDataTypeSupport_ptr native)
{
    return native->get_type_name();
}

int RobotDDS_TeleopDataTypeSupport_RegisterType(RobotDDS::TeleopDataTypeSupport_ptr native, ::DDS::DomainParticipant_ptr dp, const char* typeName)
{
    return native->register_type(dp, typeName);
}

int RobotDDS_TeleopDataTypeSupport_UnregisterType(RobotDDS::TeleopDataTypeSupport_ptr native, ::DDS::DomainParticipant_ptr dp, const char* typeName)
{
    return native->unregister_type(dp, typeName);
}

RobotDDS::TeleopDataDataWriter_ptr RobotDDS_TeleopDataDataWriter_Narrow(DDS::DataWriter_ptr dw)
{
    return RobotDDS::TeleopDataDataWriter::_narrow(dw);
}

int RobotDDS_TeleopDataDataWriter_Write_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, int handle)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    ::DDS::ReturnCode_t ret = dw->write(sample, handle);

    return ret;
}

int RobotDDS_TeleopDataDataWriter_Write_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, int handle)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);

    ::DDS::ReturnCode_t ret = dw->write(sample, handle);

    return ret;
}

int RobotDDS_TeleopDataDataWriter_WriteWithTimestamp_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, int handle, ::DDS::Time_t time)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->write_w_timestamp(sample, handle, time);
}

int RobotDDS_TeleopDataDataWriter_WriteWithTimestamp_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, int handle, const char* time_data, size_t time_size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);
    ::DDS::Time_t time = marshal::dds_time_deserialize_from_bytes(time_data, time_size);

    return dw->write_w_timestamp(sample, handle, time);
}

int RobotDDS_TeleopDataDataWriter_RegisterInstance_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->register_instance(sample);
}

int RobotDDS_TeleopDataDataWriter_RegisterInstance_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);

    return dw->register_instance(sample);
}

int RobotDDS_TeleopDataDataWriter_RegisterInstanceTimestamp_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, ::DDS::Time_t time)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->register_instance_w_timestamp(sample, time);
}

int RobotDDS_TeleopDataDataWriter_RegisterInstanceTimestamp_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, const char* time_data, size_t time_size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);
    ::DDS::Time_t time = marshal::dds_time_deserialize_from_bytes(time_data, time_size);

    return dw->register_instance_w_timestamp(sample, time);
}

int RobotDDS_TeleopDataDataWriter_UnregisterInstance_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, ::DDS::InstanceHandle_t handle)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->unregister_instance(sample, handle);
}

int RobotDDS_TeleopDataDataWriter_UnregisterInstance_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, ::DDS::InstanceHandle_t handle)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);

    return dw->unregister_instance(sample, handle);
}

int RobotDDS_TeleopDataDataWriter_UnregisterInstanceTimestamp_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, ::DDS::InstanceHandle_t handle, ::DDS::Time_t time)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->unregister_instance_w_timestamp(sample, handle, time);
}

int RobotDDS_TeleopDataDataWriter_UnregisterInstanceTimestamp_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, ::DDS::InstanceHandle_t handle, const char* time_data, size_t time_size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);
    ::DDS::Time_t time = marshal::dds_time_deserialize_from_bytes(time_data, time_size);

    return dw->unregister_instance_w_timestamp(sample, handle, time);
}

int RobotDDS_TeleopDataDataWriter_LookupInstance_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->lookup_instance(sample);
}

int RobotDDS_TeleopDataDataWriter_LookupInstance_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);

    return dw->lookup_instance(sample);
}

int RobotDDS_TeleopDataDataWriter_Dispose_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, int handle)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->dispose(sample, handle);
}

int RobotDDS_TeleopDataDataWriter_Dispose_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, int handle)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);

    return dw->dispose(sample, handle);
}

int RobotDDS_TeleopDataDataWriter_DisposeTimestamp_Json(RobotDDS::TeleopDataDataWriter_ptr dw, const char* json_data, int handle, ::DDS::Time_t time)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dw->dispose_w_timestamp(sample, handle, time);
}

int RobotDDS_TeleopDataDataWriter_DisposeTimestamp_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, const char* cdr_data, size_t size, int handle, const char* time_data, size_t time_size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);
    ::DDS::Time_t time = marshal::dds_time_deserialize_from_bytes(time_data, time_size);

    return dw->dispose_w_timestamp(sample, handle, time);
}

int RobotDDS_TeleopDataDataWriter_GetKeyValue_Json(RobotDDS::TeleopDataDataWriter_ptr dw, char* & json_data, int handle)
{
    RobotDDS::TeleopData sample_key;
    ::DDS::ReturnCode_t ret = dw->get_key_value(sample_key, handle);

    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS::TeleopData sample = RobotDDS_TeleopData_DecodeJsonSample(json_data);
        RobotDDS_TeleopData_CopyKeys(&sample_key, &sample);
        json_data = RobotDDS_TeleopData_EncodeJsonSample(sample);
    }

    return ret;
}

int RobotDDS_TeleopDataDataWriter_GetKeyValue_Cdr(RobotDDS::TeleopDataDataWriter_ptr dw, char* & cdr_data, size_t & size, int handle)
{
    RobotDDS::TeleopData sample_key;
    ::DDS::ReturnCode_t ret = dw->get_key_value(sample_key, handle);

    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopData_serialize_to_bytes(sample_key, cdr_data, size);
    }

    return ret;
}

RobotDDS::TeleopDataDataReader_ptr RobotDDS_TeleopDataDataReader_Narrow(DDS::DataReader_ptr dr)
{
    return RobotDDS::TeleopDataDataReader::_narrow(dr);
}

int RobotDDS_TeleopDataDataReader_ReadNextSample_Json(RobotDDS::TeleopDataDataReader_ptr dr, char* & json_data, ::DDS::SampleInfo* sampleInfo)
{
    RobotDDS::TeleopData sample;
    ::DDS::ReturnCode_t ret = dr->read_next_sample(sample, *sampleInfo);

    if (ret == ::DDS::RETCODE_OK)
    {
        json_data = RobotDDS_TeleopData_EncodeJsonSample(sample);
    }

    return (int)ret;
}

int RobotDDS_TeleopDataDataReader_ReadNextSample_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char* & cdr_data, size_t & size, char* & cdr_info, size_t & size_info)
{
    RobotDDS::TeleopData sample;
    ::DDS::SampleInfo sampleInfo;
    ::DDS::ReturnCode_t ret = dr->read_next_sample(sample, sampleInfo);

    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopData_serialize_to_bytes(sample, cdr_data, size);
        marshal::dds_sample_info_serialize_to_bytes(sampleInfo, cdr_info, size_info);
    }

    return (int)ret;
}

int RobotDDS_TeleopDataDataReader_TakeNextSample_Json(RobotDDS::TeleopDataDataReader_ptr dr, char* & json_data, ::DDS::SampleInfo* sampleInfo)
{
    RobotDDS::TeleopData sample;
    ::DDS::ReturnCode_t ret = dr->take_next_sample(sample, *sampleInfo);

    if (ret == ::DDS::RETCODE_OK)
    {
        json_data = RobotDDS_TeleopData_EncodeJsonSample(sample);
    }

    return (int)ret;
}

int RobotDDS_TeleopDataDataReader_TakeNextSample_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char* & cdr_data, size_t & size_data, char* & cdr_info, size_t & size_info)
{
    RobotDDS::TeleopData sample;
    ::DDS::SampleInfo sampleInfo;
    ::DDS::ReturnCode_t ret = dr->take_next_sample(sample, sampleInfo);

    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopData_serialize_to_bytes(sample, cdr_data, size_data);
        marshal::dds_sample_info_serialize_to_bytes(sampleInfo, cdr_info, size_info);
    }

    return (int)ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_Read_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->read(received_data, info_seq, maxSamples, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_Read_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->read(received_data, info_seq, maxSamples, sampleStates, viewStates, instanceStates);

    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadWithCondition_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->read_w_condition(received_data, info_seq, maxSamples, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadWithCondition_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->read_w_condition(received_data, info_seq, maxSamples, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_Take_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take(received_data, info_seq, maxSamples, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_Take_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take(received_data, info_seq, maxSamples, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeWithCondition_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->take_w_condition(received_data, info_seq, maxSamples, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeWithCondition_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->take_w_condition(received_data, info_seq, maxSamples, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

int RobotDDS_TeleopDataDataReader_LookupInstance_Json(RobotDDS::TeleopDataDataReader_ptr dr, const char* json_data)
{
    RobotDDS::TeleopData_var samplev = RobotDDS_TeleopData_DecodeJsonSample(json_data);
    if (samplev == NULL)
    {
        return ::DDS::RETCODE_ERROR;
    }
    RobotDDS::TeleopData sample = samplev.in();

    return dr->lookup_instance(sample);
}


int RobotDDS_TeleopDataDataReader_LookupInstance_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, const char* cdr_data, size_t size)
{
    RobotDDS::TeleopData sample = RobotDDS_TeleopData_deserialize_from_bytes(cdr_data, size);

    return dr->lookup_instance(sample);
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadInstance_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->read_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadInstance_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->read_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadInstanceWithCondition_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->read_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadInstanceWithCondition_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->read_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeInstance_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeInstance_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeInstanceWithCondition_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->take_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeInstanceWithCondition_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;

    ::DDS::ReturnCode_t ret = dr->take_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadNextInstance_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->read_next_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadNextInstance_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->read_next_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadNextInstanceWithCondition_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->read_next_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_ReadNextInstanceWithCondition_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->read_next_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeNextInstance_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take_next_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeNextInstance_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::SampleStateMask sampleStates, ::DDS::ViewStateMask viewStates, ::DDS::InstanceStateMask instanceStates)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take_next_instance(received_data, info_seq, maxSamples, handle, sampleStates, viewStates, instanceStates);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeNextInstanceWithCondition_Json(RobotDDS::TeleopDataDataReader_ptr dr, void*& receivedData, void*& receivedInfo, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take_next_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        TAO::unbounded_value_sequence<char*> seq(received_data.length());
        seq.length(received_data.length());
        for (unsigned int i = 0; i < received_data.length(); i++) {
            seq[i] = RobotDDS_TeleopData_EncodeJsonSample(received_data[i]);;
        }

        marshal::unbounded_sequence_to_ptr(seq, receivedData);
        marshal::unbounded_sequence_to_ptr(info_seq, receivedInfo);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

::DDS::ReturnCode_t RobotDDS_TeleopDataDataReader_TakeNextInstanceWithCondition_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char*& cdr_data, size_t & size_data, char*& cdr_info, size_t & size_info, ::DDS::InstanceHandle_t handle, CORBA::Long maxSamples, ::DDS::ReadCondition_ptr condition)
{
    RobotDDS::TeleopDataSeq received_data;
    ::DDS::SampleInfoSeq info_seq;
    ::DDS::ReturnCode_t ret = dr->take_next_instance_w_condition(received_data, info_seq, maxSamples, handle, condition);
    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS_TeleopDataSeq_serialize_to_bytes(received_data, cdr_data, size_data);
        marshal::dds_sample_info_seq_serialize_to_bytes(info_seq, cdr_info, size_info);

        dr->return_loan(received_data, info_seq);
    }

    return ret;
}

int RobotDDS_TeleopDataDataReader_GetKeyValue_Json(RobotDDS::TeleopDataDataReader_ptr dr, char* & json_data, int handle)
{
    RobotDDS::TeleopData sample_key;
    ::DDS::ReturnCode_t ret = dr->get_key_value(sample_key, handle);

    if (ret == ::DDS::RETCODE_OK)
    {
        RobotDDS::TeleopData sample = RobotDDS_TeleopData_DecodeJsonSample(json_data);
        RobotDDS_TeleopData_CopyKeys(&sample_key, &sample);
        json_data = RobotDDS_TeleopData_EncodeJsonSample(sample);
    }

    return ret;
}

int RobotDDS_TeleopDataDataReader_GetKeyValue_Cdr(RobotDDS::TeleopDataDataReader_ptr dr, char* & cdr_data, size_t & size_data, int handle)
{
    RobotDDS::TeleopData sample_key;
    ::DDS::ReturnCode_t ret = dr->get_key_value(sample_key, handle);

    if (ret == ::DDS::RETCODE_OK)
    {
       RobotDDS_TeleopData_serialize_to_bytes(sample_key, cdr_data, size_data);
    }

    return ret;
}
